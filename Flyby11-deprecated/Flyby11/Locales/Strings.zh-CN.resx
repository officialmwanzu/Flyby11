<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="compPatch_debugCancel" xml:space="preserve">
    <value>用户取消安装绕过补丁</value>
  </data>
  <data name="compPatch_debugNotRemovableDrive" xml:space="preserve">
    <value>用户尝试选择了一个不可弹出的设备。</value>
  </data>
  <data name="compPatch_debugNoUSBDrive" xml:space="preserve">
    <value>未选择 USB 设备来安装绕过补丁。</value>
  </data>
  <data name="compPatch_msgFailedEx" xml:space="preserve">
    <value>安装绕过补丁失败：</value>
  </data>
  <data name="compPatch_msgNotRemovableDrive" xml:space="preserve">
    <value>已选位置不是一个可弹出的设备。请选择一个正确的 USB 设备。</value>
  </data>
  <data name="compPatch_msgSelectDrive" xml:space="preserve">
    <value>请选择包含 Windows 11 安装文件的 USB 设备。\n该功能用于添加兼容性补丁来绕过某些强制要求。\n兼容由任何工具（包括 Rufus）准备的设备。请确保设备已准备好！</value>
  </data>
  <data name="compPatch_msgSelectDriveConfirm" xml:space="preserve">
    <value>即将在 USB 设备中安装兼容性绕过补丁。继续？</value>
  </data>
  <data name="compPatch_msgSuccess" xml:space="preserve">
    <value>绕过补丁已成功安装！</value>
  </data>
  <data name="ctl_FormTitle" xml:space="preserve">
    <value>Flyby11 升级助手</value>
  </data>
  <data name="ctl_inkCompPatch" xml:space="preserve">
    <value>为 ISO 应用兼容性补丁（全新安装）</value>
  </data>
  <data name="ctl_linkCiuv" xml:space="preserve">
    <value>我的设备支持升级到 Windows 11 吗？</value>
  </data>
  <data name="ctl_linkVote" xml:space="preserve">
    <value>升级对您来说有用吗？</value>
  </data>
  <data name="ctl_statusLabel" xml:space="preserve">
    <value>拖入 Windows 11 ISO 文件来安装补丁，以支持安装进不支持的硬件（直接升级）。</value>
  </data>
  <data name="faq_a1" xml:space="preserve">
    <value>答：您可从微软官方网站或 Fido 下载器下载最新版 ISO</value>
  </data>
  <data name="faq_a2" xml:space="preserve">
    <value>答：如果您因本程序成功安装了 Windows 11，并让您省了点钱。可以随意在这里留下点小小的感谢！</value>
  </data>
  <data name="faq_a2Link" xml:space="preserve">
    <value>点击这里捐赠并表达您的支持。</value>
  </data>
  <data name="faq_a3" xml:space="preserve">
    <value>答：一旦 ISO 文件被挂载，安装过程将在后台运行。Windows 安装程序会启动，并引导您完成安装 Windows 11 所需的各项步骤。</value>
  </data>
  <data name="faq_a4" xml:space="preserve">
    <value>答：请检查错误信息，并将其报告到 GitHub 上。</value>
  </data>
  <data name="faq_a5" xml:space="preserve">
    <value>答：是的，微软确实留下了一个后门。此方法利用了 Windows 11 安装过程中的一个功能，该功能使用了 Windows Server 版本的安装程序。与常规的 Windows 11 安装程序不同，这个版本会跳过大多数硬件兼容性检查。</value>
  </data>
  <data name="faq_a6" xml:space="preserve">
    <value>答：根据微软的说法，你应该扔掉你的电脑。但我建议你在电脑上安装 Linux，远离 Windows。</value>
  </data>
  <data name="faq_a7" xml:space="preserve">
    <value>答：开发者是 Belim，也被称为 Builtbybel，他为 Windows 社区贡献了大量代码。</value>
  </data>
  <data name="faq_a7Link" xml:space="preserve">
    <value>点击此处了解更多关于该开发者工作的信息。</value>
  </data>
  <data name="faq_downloadFido" xml:space="preserve">
    <value>通过 Fido 下载（推荐）</value>
  </data>
  <data name="faq_downloadMS" xml:space="preserve">
    <value>微软官网</value>
  </data>
  <data name="faq_header" xml:space="preserve">
    <value>常见问题解答</value>
  </data>
  <data name="faq_q1" xml:space="preserve">
    <value>问：我在哪里可以下载最新的 Windows 11 ISO 文件？</value>
  </data>
  <data name="faq_q2" xml:space="preserve">
    <value>问：如何支持开发者？</value>
  </data>
  <data name="faq_q3" xml:space="preserve">
    <value>问：挂载 ISO 文件后，安装过程是如何进行的？</value>
  </data>
  <data name="faq_q4" xml:space="preserve">
    <value>问：如果在安装过程中遇到问题怎么办？</value>
  </data>
  <data name="faq_q5" xml:space="preserve">
    <value>问：使用这种方式是否合法？</value>
  </data>
  <data name="faq_q6" xml:space="preserve">
    <value>问：如果我的电脑不受支持，有哪些替代方案？</value>
  </data>
  <data name="faq_q7" xml:space="preserve">
    <value>问：开发者是谁？</value>
  </data>
  <data name="ciuView_lblPtAns" xml:space="preserve">
    <value>1. 设备正在运行受支持版本的 Windows 10。若设备当前未运行受支持的 Windows 10 版本，则请升级到受支持的 Windows 10 版本。</value>
  </data>
  <data name="ciuView_lblPtAns2" xml:space="preserve">
    <value>2. 该设备符合</value>
  </data>
  <data name="ciuView_lblPtAns3" xml:space="preserve">
    <value>1. 下载并运行</value>
  </data>
  <data name="ciuView_lblPtAns4" xml:space="preserve">
    <value>2. 单击下方 Windows 更新按钮，然后单击检查更新按钮：</value>
  </data>
  <data name="ciuView_lblPtAns5" xml:space="preserve">
    <value>3. 您的设备不支持 Windows 11 官方安装流程？您可安装兼容补丁来启用 Windows 更新中的内置升级</value>
  </data>
  <data name="ciuView_lblPtHdr" xml:space="preserve">
    <value>若满足以下条件，当前运行 Windows 10 的设备可直接升级到 Windows11：</value>
  </data>
  <data name="ciuView_lblPtHdr2" xml:space="preserve">
    <value>要查看 Windows 10 设备是否符合升级到 Windows 11 的条件，请按照以下其中一个选项来检查：</value>
  </data>
  <data name="ciuView_linkPtAns2" xml:space="preserve">
    <value>运行 Windows 11 的最低硬件规格要求。</value>
  </data>
  <data name="ciuView_linkPtAns3" xml:space="preserve">
    <value>WhyNotWin11 应用来确认您的设备是否符合最低硬件规格要求</value>
  </data>
  <data name="msg_InstallReady" xml:space="preserve">
    <value>现在可以继续 Windows 11 的安装。请按照安装窗口中的说明进行操作。</value>
    <comment>Install</comment>
  </data>
  <data name="_debugInstallReady" xml:space="preserve">
    <value>您已准备好在不受支持的设备中安装 Windows 11！请忽略 'Windows Server' 提示；一切已准备就绪。</value>
    <comment>Install</comment>
  </data>
  <data name="_debugInstallRunElevated" xml:space="preserve">
    <value>正在以管理员权限启动安装程序…</value>
    <comment>Install</comment>
  </data>
  <data name="_debugStatusHandleIsoEx" xml:space="preserve">
    <value>啊噢！发生错误：</value>
    <comment>Mounting</comment>
  </data>
  <data name="_debugStatusMounting" xml:space="preserve">
    <value>正在挂载 ISO… 请稍后！</value>
    <comment>Mounting</comment>
  </data>
  <data name="_debugStatusMountingFailed" xml:space="preserve">
    <value>无法挂载 ISO。请重试。</value>
    <comment>Mounting</comment>
  </data>
  <data name="_debugStatusMountingSuccess" xml:space="preserve">
    <value>已成功挂载 ISO！让我们准备好安装 Windows 11 吧！</value>
    <comment>Mounting</comment>
  </data>
  <data name="_debugStatusRunning" xml:space="preserve">
    <value>马上就完成了！我们正在完成安装中…</value>
    <comment>Install</comment>
  </data>
  <data name="_debugStatusSetupFileNotFound" xml:space="preserve">
    <value>未在此处找到安装文件：</value>
    <comment>Mounting</comment>
  </data>
  <data name="ctl_linkSelectComputer" xml:space="preserve">
    <value>从计算机中选择</value>
  </data>
  <data name="msgClosing" xml:space="preserve">
    <value />
  </data>
</root>
